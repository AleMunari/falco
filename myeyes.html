<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="MyEYES">
<meta name="theme-color" content="#000000">
<title>MyEYES</title>
<link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Crect width='180' height='180' rx='40' fill='%23000000'/%3E%3Ctext x='90' y='118' font-size='52' text-anchor='middle' font-family='Georgia,serif' fill='%23FFE600' font-weight='bold'%3EMyEYES%3C/text%3E%3C/svg%3E">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;800;900&display=swap" rel="stylesheet">
<style>
:root{--bg:#000;--card:#1a1a1a;--border:#444;--yellow:#FFE000;--green:#00C94A;--red:#FF1A1A;--muted:#aaa;--r:22px}
*{box-sizing:border-box;margin:0;padding:0;-webkit-tap-highlight-color:transparent}
html,body{height:100%;width:100%;background:var(--bg);font-family:'Nunito',sans-serif;color:#fff}
#app{display:none;position:fixed;inset:0;flex-direction:column;background:var(--bg)}
#status-bar{padding:8px 16px;padding-top:max(8px,env(safe-area-inset-top));background:var(--card);font-size:.95rem;font-weight:700;color:var(--muted);min-height:40px;display:flex;align-items:center;gap:8px;flex-shrink:0;border-bottom:2px solid var(--border)}
#status-dot{width:10px;height:10px;border-radius:50%;background:var(--muted);flex-shrink:0;transition:background .3s}
#status-dot.active{background:var(--green);animation:pulse 1.5s infinite}
#status-dot.listening{background:var(--red);animation:pulse .5s infinite}
#status-dot.error{background:#f44}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.2}}
#status-text{flex:1;font-size:.85rem}
#btn-stop-voice{padding:5px 12px;background:linear-gradient(135deg,#FF2222,#CC0000);border:none;border-radius:10px;font-family:'Nunito',sans-serif;font-size:.8rem;font-weight:900;color:#fff;cursor:pointer;flex-shrink:0;display:none}
.scroll-area{flex:1;overflow-y:auto;overflow-x:hidden;padding:10px 12px;display:flex;flex-direction:column;gap:10px;-webkit-overflow-scrolling:touch}
#preview-wrap{display:none;width:100%;border-radius:var(--r);overflow:hidden;position:relative;border:2px solid var(--yellow);max-height:160px}
#preview-img{width:100%;object-fit:cover;max-height:160px;display:block}
.preview-close{position:absolute;top:8px;right:8px;width:34px;height:34px;background:rgba(0,0,0,.75);border:none;border-radius:50%;color:#fff;font-size:1.1rem;cursor:pointer;display:flex;align-items:center;justify-content:center;font-family:'Nunito',sans-serif;font-weight:900}
.row-2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.btn{width:100%;padding:0;border:none;border-radius:var(--r);cursor:pointer;display:flex;flex-direction:column;align-items:center;justify-content:center;transition:transform .12s,filter .12s;font-family:'Nunito',sans-serif;position:relative;overflow:hidden}
.btn:active{transform:scale(.95);filter:brightness(.85)}
.btn-label{font-size:3.2rem;font-weight:900;letter-spacing:1px;line-height:1;color:#fff}

#btn-camera{background:linear-gradient(160deg,#FFF500,#FFB800);box-shadow:0 8px 36px rgba(255,220,0,.8);padding:40px 10px}
#btn-camera .btn-label{color:#000;font-size:3.4rem;letter-spacing:2px}

#btn-play{background:linear-gradient(135deg,#00E5FF,#0077FF);box-shadow:0 6px 28px rgba(0,200,255,.7);padding:40px 10px}
#btn-play.recording{background:linear-gradient(135deg,#FF2222,#CC0000);box-shadow:0 6px 28px rgba(255,30,30,.7)}
#btn-gallery{background:linear-gradient(135deg,#FF7A00,#B34400);box-shadow:0 6px 28px rgba(255,100,0,.7);padding:36px 10px}
#btn-describe{background:linear-gradient(135deg,#00FF66,#00AA44);box-shadow:0 6px 28px rgba(0,255,90,.6);padding:36px 10px}
#btn-describe .btn-label{color:#000;font-size:2.8rem}
#btn-gallery .btn-label{font-size:2.8rem}

#btn-bus{background:linear-gradient(135deg,#CC00FF,#7700BB);box-shadow:0 6px 28px rgba(180,0,255,.7);padding:36px 10px}
#btn-exit{background:linear-gradient(135deg,#FF3333,#CC0000);box-shadow:0 6px 28px rgba(255,30,30,.5);padding:36px 10px}
.wave-bar{display:none;align-items:center;justify-content:center;gap:4px;height:22px;margin-top:5px}
.wave-bar.show{display:flex}
.wave-bar span,.wave-bar-inner span{width:4px;background:#fff;border-radius:3px;animation:wave .7s ease-in-out infinite}
.wave-bar span:nth-child(1){height:6px;animation-delay:0s}.wave-bar span:nth-child(2){height:16px;animation-delay:.1s}.wave-bar span:nth-child(3){height:22px;animation-delay:.2s}.wave-bar span:nth-child(4){height:12px;animation-delay:.3s}.wave-bar span:nth-child(5){height:18px;animation-delay:.15s}.wave-bar span:nth-child(6){height:9px;animation-delay:.25s}.wave-bar span:nth-child(7){height:16px;animation-delay:.05s}
@keyframes wave{0%,100%{transform:scaleY(1)}50%{transform:scaleY(.25)}}
#voice-transcript{text-align:center;font-size:.9rem;font-weight:700;color:var(--muted);line-height:1.4;padding:0 4px;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}
#gtt-panel{display:none;background:var(--card);border:2px solid var(--border);border-radius:var(--r);padding:14px 12px;flex-direction:column;gap:10px}
#gtt-panel.open{display:flex}
.gtt-title{font-size:1.1rem;font-weight:900;color:var(--yellow);text-align:center;letter-spacing:1px}
.gtt-note{font-size:.75rem;font-weight:700;color:#555;text-align:center}
#gtt-coords{font-size:.85rem;font-weight:700;color:var(--muted);text-align:center;line-height:1.4}
#btn-gtt-location{width:100%;padding:20px;background:#fff;border:none;border-radius:16px;font-family:'Nunito',sans-serif;font-size:1.4rem;font-weight:900;color:#000;cursor:pointer;transition:filter .12s,transform .12s}
#btn-gtt-location:active{filter:brightness(.85);transform:scale(.97)}
#btn-gtt-mic{width:100%;padding:24px 10px;background:linear-gradient(135deg,#00E5FF,#0077FF);box-shadow:0 6px 28px rgba(0,200,255,.7);border:none;border-radius:var(--r);font-family:'Nunito',sans-serif;font-size:2rem;font-weight:900;color:#fff;cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:4px;transition:background .2s,box-shadow .2s}
#btn-gtt-mic.recording{background:linear-gradient(135deg,#FF2222,#CC0000);box-shadow:0 6px 28px rgba(255,30,30,.7)}
#gtt-mic-sub{font-size:.9rem;font-weight:700;color:rgba(255,255,255,.8)}
.gtt-section-title{font-size:.8rem;font-weight:900;color:#666;letter-spacing:2px;text-transform:uppercase;text-align:center}
.gtt-subsection{display:grid;grid-template-columns:1fr 1fr;gap:8px}
#btn-gtt-voce-fermata.recording{background:linear-gradient(135deg,#FF2222,#CC0000) !important;box-shadow:0 6px 28px rgba(255,30,30,.7)}
#gtt-wave-bar{display:none;align-items:center;justify-content:center;gap:4px;height:20px}
#gtt-wave-bar.show{display:flex}
#gtt-wave-bar span{width:4px;background:#fff;border-radius:3px;animation:wave .7s ease-in-out infinite}
#gtt-wave-bar span:nth-child(1){height:5px;animation-delay:0s}#gtt-wave-bar span:nth-child(2){height:14px;animation-delay:.1s}#gtt-wave-bar span:nth-child(3){height:20px;animation-delay:.2s}#gtt-wave-bar span:nth-child(4){height:10px;animation-delay:.3s}#gtt-wave-bar span:nth-child(5){height:16px;animation-delay:.15s}
#gtt-answer{font-size:.9rem;font-weight:700;color:var(--muted);text-align:center;line-height:1.5;padding:0 4px;min-height:20px}
#btn-gtt-realtime{width:100%;padding:16px;background:linear-gradient(135deg,#FFB800,#FF7A00);border:none;border-radius:16px;font-family:'Nunito',sans-serif;font-size:1.1rem;font-weight:900;color:#000;cursor:pointer}
#settings-fab{position:fixed;bottom:max(18px,env(safe-area-inset-bottom));right:16px;width:42px;height:42px;background:var(--yellow);border:none;border-radius:12px;color:#000;font-size:1.2rem;display:flex;align-items:center;justify-content:center;cursor:pointer;z-index:200;box-shadow:0 4px 16px rgba(255,220,0,.6)}
#settings-overlay{display:none;position:fixed;inset:0;z-index:300;background:rgba(0,0,0,.8);align-items:flex-end}
#settings-overlay.open{display:flex}
.settings-sheet{width:100%;background:var(--card);border-radius:24px 24px 0 0;padding:22px 22px max(22px,env(safe-area-inset-bottom));display:flex;flex-direction:column;gap:14px}
.s-handle{width:44px;height:5px;background:var(--border);border-radius:3px;margin:0 auto 4px}
.s-title{font-size:1.2rem;font-weight:900;color:var(--yellow)}
.s-row{display:flex;gap:10px}
.s-input{flex:1;padding:14px 16px;background:var(--bg);border:2px solid var(--border);border-radius:14px;color:#fff;font-family:'Nunito',sans-serif;font-size:1rem;font-weight:700;outline:none}
.s-save{padding:14px 18px;background:var(--yellow);color:#000;border:none;border-radius:14px;font-family:'Nunito',sans-serif;font-weight:900;font-size:1rem;cursor:pointer}
.s-close{padding:14px;background:var(--border);border:none;border-radius:14px;color:var(--muted);font-family:'Nunito',sans-serif;font-size:1rem;font-weight:700;cursor:pointer;text-align:center}
.s-info{font-size:.85rem;font-weight:700;color:var(--muted);line-height:1.5}
.s-info a{color:var(--yellow)}
#exit-screen{display:none;position:fixed;inset:0;z-index:999;background:#000;flex-direction:column;align-items:center;justify-content:center;gap:24px;padding:40px}
.exit-title{font-size:2.5rem;font-weight:900;color:var(--yellow);text-align:center}
.exit-msg{font-size:1.2rem;font-weight:700;color:#aaa;text-align:center;line-height:1.6}
#exit-reopen{padding:20px 40px;background:linear-gradient(135deg,#FFF500,#FFB800);border:none;border-radius:22px;font-family:'Nunito',sans-serif;font-size:1.4rem;font-weight:900;color:#000;cursor:pointer}
.bottom-spacer{height:max(60px,calc(env(safe-area-inset-bottom) + 60px));flex-shrink:0}
</style>
</head>
<body>
<div id="app">
  <div id="status-bar">
    <div id="status-dot"></div>
    <div id="status-text">Pronto.</div>
    <button id="btn-stop-voice" onclick="stopVoice()">STOP VOCE</button>
  </div>
  <div class="scroll-area">
    <div id="preview-wrap">
      <img id="preview-img" src="" alt="">
      <button class="preview-close" onclick="clearImage()">X</button>
    </div>
    <div class="row-2">
      <button class="btn" id="btn-camera" onclick="openCamera()">
        <span class="btn-label">FOTO</span>
      </button>
      <button class="btn" id="btn-play" onclick="toggleRecording()">
        <span class="btn-label" id="play-label">CHIEDI</span>
        
        <div class="wave-bar" id="wave-bar"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></div>
      </button>
    </div>
    <div class="row-2">
      <button class="btn" id="btn-gallery" onclick="openGallery()">
        <span class="btn-label">GALLERIA</span>
      </button>
      <button class="btn" id="btn-describe" onclick="describeScene()">
        <span class="btn-label">ANALISI AI</span>
      </button>
    </div>
    <div class="row-2">
      <button class="btn" id="btn-bus" onclick="toggleGTT()">
        <span class="btn-label">BUS</span>
      </button>
      <button class="btn" id="btn-exit" onclick="exitApp()">
        <span class="btn-label">ESCI</span>
      </button>
    </div>
    <div id="voice-transcript">Premi CHIEDI e parla. Premi di nuovo per fermare.</div>
    <div id="gtt-panel">
      <div class="gtt-title">üöå GTT TORINO</div>

      <!-- SEZIONE 1: ORARI FERMATA (funzione principale) -->
      <div class="gtt-section-title">ORARI ALLA FERMATA</div>
      <div class="gtt-subsection">
        <button id="btn-gtt-foto-fermata" class="btn" style="background:linear-gradient(135deg,#FFF500,#FFB800);padding:18px 10px;margin-bottom:0" onclick="readStopFromPhoto()">
          <span class="btn-label" style="color:#000;font-size:1.4rem">üì∑ LEGGI FOTO</span>
          
        </button>
        <button id="btn-gtt-voce-fermata" class="btn" style="background:linear-gradient(135deg,#00E5FF,#0077FF);padding:18px 10px;margin-bottom:0" onclick="toggleStopVoice()">
          <span id="gtt-stop-label" class="btn-label" style="font-size:1.4rem">üé§ DI' FERMATA</span>
          
          <div id="gtt-stop-wave" class="wave-bar"><span></span><span></span><span></span><span></span><span></span></div>
        </button>
      </div>
      <div id="gtt-stop-answer" style="font-size:1.25rem;font-weight:800;color:#FFE000;text-align:center;line-height:1.7;padding:8px 4px;min-height:20px;white-space:pre-line"></div>
      <div style="display:flex;gap:8px;margin-top:6px">
        <button id="btn-gtt-leggi" onclick="leggiOrari()" style="display:none;flex:1;padding:18px;background:linear-gradient(135deg,#00E676,#00897B);border:none;border-radius:16px;font-family:'Nunito',sans-serif;font-size:1.3rem;font-weight:900;color:#000;cursor:pointer">üîä LEGGI</button>
        <button id="btn-gtt-apri" onclick="openGTTStopPage()" style="display:none;flex:1;padding:18px;background:linear-gradient(135deg,#7700BB,#CC00FF);border:none;border-radius:16px;font-family:'Nunito',sans-serif;font-size:1.1rem;font-weight:900;color:#fff;cursor:pointer">üåê APRI GTT</button>
      </div>

      <div style="height:1px;background:#333;margin:4px 0"></div>

      <!-- SEZIONE 2: DOVE DEVO ANDARE (funzione secondaria) -->
      <div class="gtt-section-title">DOVE DEVO ANDARE?</div>
      <div id="gtt-coords" style="font-size:.8rem;font-weight:700;color:#888;text-align:center">Prima rileva la posizione.</div>
      <button id="btn-gtt-location" onclick="getUserLocation()">üìç RILEVA POSIZIONE</button>
      <button id="btn-gtt-mic" onclick="toggleGTTVoice()">
        <span id="gtt-mic-label">üé§ CHIEDI</span>
        
        <div id="gtt-wave-bar"><span></span><span></span><span></span><span></span><span></span></div>
      </button>
      <div id="gtt-answer" style="font-size:.9rem;font-weight:700;color:var(--muted);text-align:center;line-height:1.5;padding:0 4px;min-height:20px"></div>

    </div>
    <div class="bottom-spacer"></div>
  </div>
</div>

<button id="settings-fab" onclick="openSettings()">&#9881;</button>

<div id="settings-overlay" onclick="closeSettingsIfBg(event)">
  <div class="settings-sheet">
    <div class="s-handle"></div>
    <div class="s-title">IMPOSTAZIONI</div>
    <div class="s-row">
      <input class="s-input" id="settings-key" type="password" placeholder="gsk_..." autocomplete="off">
      <button class="s-save" onclick="saveKeyFromSettings()">SALVA</button>
    </div>
    <p class="s-info">API Key Groq ‚Äî gratuita su <a href="https://console.groq.com/keys" target="_blank">console.groq.com/keys</a></p>
    <button class="s-close" onclick="closeSettings()">CHIUDI</button>
  </div>
</div>

<div id="exit-screen">
  <div class="exit-title">ARRIVEDERCI</div>
  <div class="exit-msg">Chiudi questa scheda dal browser o torna all'app.</div>
  <button id="exit-reopen" onclick="reopenApp()">TORNA ALL'APP</button>
</div>

<input type="file" id="file-camera" accept="image/*" capture="environment" style="display:none" onchange="handleFileInput(event)">
<input type="file" id="file-gallery" accept="image/*" style="display:none" onchange="handleFileInput(event)">

<script>
'use strict';

// ‚ïê‚ïê‚ïê STATE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let apiKey             = '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';
let currentImageBase64 = null;
let recognition        = null;
let isRecording        = false;
let accumulatedTranscript = '';
let gttRecognition     = null;
let isGttRecording     = false;
let gttTranscript      = '';
let gttOpen            = false;
let userLat            = null;
let userLon            = null;
let lastGTTLineNumber  = '';
// FLAG CRITICO: impedisce doppia chiamata a processGTTVoice
let gttProcessing      = false;
let lastVoiceText      = '';

// ‚ïê‚ïê‚ïê INIT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
window.addEventListener('DOMContentLoaded', () => {
  document.getElementById('app').style.display = 'flex';
  setStatus('Pronto.', 'idle');
  setTimeout(() => speak('MyEyes pronto.'), 600);
  ['btn-camera','btn-gallery','btn-describe','btn-bus','btn-exit'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('touchstart', () => navigator.vibrate && navigator.vibrate(20), {passive:true});
  });
});

// ‚ïê‚ïê‚ïê STATUS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function setStatus(msg, state) {
  document.getElementById('status-text').textContent = msg;
  document.getElementById('status-dot').className =
    state === 'active' ? 'active' : state === 'listening' ? 'listening' : state === 'error' ? 'error' : '';
}

// ‚ïê‚ïê‚ïê TTS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function speak(text, onEnd) {
  if (!text) { if (onEnd) onEnd(); return; }
  window.speechSynthesis.cancel();

  // iOS Safari blocca testi lunghi: spezza per punteggiatura
  const chunks = text.match(/[^.!?„ÄÇ]+[.!?„ÄÇ]?/g) || [text];
  const filtered = chunks.map(c => c.trim()).filter(c => c.length > 0);
  if (filtered.length === 0) { if (onEnd) onEnd(); return; }

  document.getElementById('btn-stop-voice').style.display = 'block';

  let i = 0;
  function speakNext() {
    // delay prima del primo chunk: d√† tempo a Safari di completare il cancel()
    if (i === 0) { setTimeout(_speakNext, 80); return; }
    _speakNext();
  }
  function _speakNext() {
    if (i >= filtered.length) {
      document.getElementById('btn-stop-voice').style.display = 'none';
      if (onEnd) onEnd();
      return;
    }
    const u = new SpeechSynthesisUtterance(filtered[i++]);
    u.lang = 'it-IT'; u.rate = 0.93; u.pitch = 1; u.volume = 1;
    u.onend = _speakNext;
    u.onerror = (e) => {
      if (e.error === 'interrupted' || e.error === 'canceled') {
        document.getElementById('btn-stop-voice').style.display = 'none';
        if (onEnd) onEnd();
        return;
      }
      _speakNext(); // salta chunk problematico
    };
    window.speechSynthesis.speak(u);
  }
  speakNext();
}

function stopVoice() {
  window.speechSynthesis.cancel();
  document.getElementById('btn-stop-voice').style.display = 'none';
}

// ‚ïê‚ïê‚ïê CAMERA / GALLERY ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function openCamera()  { document.getElementById('file-camera').click(); }
function openGallery() { document.getElementById('file-gallery').click(); }

function handleFileInput(event) {
  const file = event.target.files[0];
  event.target.value = '';
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    currentImageBase64 = e.target.result.split(',')[1];
    document.getElementById('preview-img').src = e.target.result;
    document.getElementById('preview-wrap').style.display = 'block';
    setStatus('Immagine caricata.', 'active');
    speak('Immagine caricata. Tocca Analisi AI per la descrizione.');
  };
  reader.readAsDataURL(file);
}

function clearImage() {
  currentImageBase64 = null;
  document.getElementById('preview-wrap').style.display = 'none';
  document.getElementById('preview-img').src = '';
  setStatus('Immagine rimossa.', 'idle');
}

// ‚ïê‚ïê‚ïê ANALISI AI ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function describeScene() {
  if (!currentImageBase64) { speak('Nessuna immagine. Scatta prima una foto.'); return; }
  setStatus('Analisi AI in corso...', 'active');
  speak('Analizzo la scena.');
  const prompt = `Sei un assistente vocale per ipovedenti. Analizza l immagine e descrivi in italiano parlato (max 5 frasi, zero elenchi, zero simboli):
1. Cosa c e di piu importante.
2. Pericoli o ostacoli per chi cammina.
3. Semafori: colore esatto.
4. Indicazioni utili: insegne, nomi strade.
Inizia con: "Davanti a te..."`;
  try {
    const result = await callGroqVision(prompt, currentImageBase64);
    setStatus('Analisi completata.', 'active');
    speak(result);
  } catch (e) {
    speak('Errore durante l analisi. Controlla la connessione.');
    setStatus('Errore.', 'error');
  }
}

// ‚ïê‚ïê‚ïê CHIEDI PRINCIPALE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function toggleRecording() {
  if (isRecording) stopRecording();
  else             startRecording();
}

function startRecording() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) { setStatus('Usa Safari su iPhone.', 'error'); return; }
  window.speechSynthesis.cancel();
  document.getElementById('btn-stop-voice').style.display = 'none';
  accumulatedTranscript = '';
  isRecording = true;
  document.getElementById('voice-transcript').textContent = 'In ascolto...';
  setStatus('In ascolto...', 'listening');
  document.getElementById('wave-bar').classList.add('show');
  document.getElementById('btn-play').classList.add('recording');
  document.getElementById('play-label').textContent = 'STOP';
  document.getElementById('play-sub').textContent = 'Tocca per fermare';
  recognition = new SR();
  recognition.lang = 'it-IT';
  recognition.continuous = true;
  recognition.interimResults = true;
  recognition.maxAlternatives = 1;
  recognition.onresult = (e) => {
    let fin = '', int = '';
    for (let i = e.resultIndex; i < e.results.length; i++) {
      if (e.results[i].isFinal) fin += e.results[i][0].transcript + ' ';
      else int += e.results[i][0].transcript;
    }
    accumulatedTranscript += fin;
    document.getElementById('voice-transcript').textContent = (accumulatedTranscript + int).trim() || 'In ascolto...';
  };
  recognition.onerror = (e) => {
    if (e.error === 'no-speech' || e.error === 'aborted') return;
    isRecording = false; resetVoiceUI();
    setStatus(e.error === 'not-allowed' ? 'Permesso negato.' : 'Errore: ' + e.error, 'error');
  };
  recognition.onend = () => {
    if (isRecording) { try { recognition.start(); } catch(err) { isRecording = false; resetVoiceUI(); processVoiceInput(); } }
  };
  try { recognition.start(); }
  catch(e) { isRecording = false; resetVoiceUI(); setStatus('Errore avvio mic.', 'error'); }
}

function stopRecording() {
  if (!isRecording) return;
  isRecording = false;
  if (recognition) {
    recognition.onend   = null;
    recognition.onerror = null;
    const rec = recognition;
    recognition = null;
    try { rec.stop(); } catch(e){}
    // Lascia 400ms per l'ultimo onresult finale, poi processa
    setTimeout(() => { try { rec.onresult = null; } catch(e){} }, 400);
  }
  resetVoiceUI();
  setTimeout(processVoiceInput, 500);
}

function resetVoiceUI() {
  document.getElementById('wave-bar').classList.remove('show');
  document.getElementById('btn-play').classList.remove('recording');
  document.getElementById('play-label').textContent = 'CHIEDI';
  document.getElementById('play-sub').textContent = 'Parla';
}

async function processVoiceInput() {
  const transcript = accumulatedTranscript.trim();
  if (!transcript) {
    speak('Non ho sentito nulla. Riprova.');
    document.getElementById('voice-transcript').textContent = 'Non ho sentito nulla.';
    setStatus('Nessuna parola.', 'idle');
    return;
  }
  document.getElementById('voice-transcript').textContent = transcript;
  setStatus('Elaboro...', 'active');
  const lo = transcript.toLowerCase();
  if (/\b(scatta|fotocamera|foto)\b/.test(lo))             { openCamera(); return; }
  if (/\b(galleria|scegli)\b/.test(lo))                    { openGallery(); return; }
  if (/\b(descrivi|analizza|analisi)\b/.test(lo))          { describeScene(); return; }
  if (/\b(esci|chiudi)\b/.test(lo))                        { exitApp(); return; }

  // Rilevazione fermata GTT: "fermata 1234" o "palina 1234" o "orari fermata 1234"
  const fermataMatch = lo.match(/(?:fermata|palina|stop|orari)\s+(\d{2,5})/);
  if (fermataMatch) {
    const stopNum = fermataMatch[1];
    document.getElementById('voice-transcript').textContent = 'Cerco orari fermata ' + stopNum + '...';
    if (!gttOpen) toggleGTT();
    setTimeout(async () => {
      setGTTStopAnswer('Cerco fermata ' + stopNum + '...');
      await processStopNumber(stopNum);
    }, 300);
    return;
  }

  if (/\b(bus|tram|orari|fermata)\b/.test(lo))             { if (!gttOpen) toggleGTT(); return; }
  try {
    const answer = currentImageBase64
      ? await callGroqVision(`Utente chiede: "${transcript}". Rispondi in italiano, max 3 frasi, zero simboli.`, currentImageBase64)
      : await callGroqChat(transcript);
    const clean = answer.replace(/[*_#`>]/g, '').trim();
    document.getElementById('voice-transcript').textContent = clean;
    speak(clean);
    setStatus('Risposta pronta.', 'active');
  } catch (e) {
    speak('Errore di rete.');
    setStatus('Errore.', 'error');
  }
}

// ‚ïê‚ïê‚ïê GROQ API ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function callGroqVision(prompt, imageBase64) {
  const res = await fetch('https://api.groq.com/openai/v1/chat/completions', {
    method: 'POST',
    headers: {'Content-Type':'application/json','Authorization':'Bearer ' + apiKey},
    body: JSON.stringify({
      model: 'meta-llama/llama-4-scout-17b-16e-instruct',
      messages: [{role:'user', content:[
        {type:'text', text:prompt},
        {type:'image_url', image_url:{url:'data:image/jpeg;base64,' + imageBase64}}
      ]}],
      max_tokens: 400
    })
  });
  if (!res.ok) { const e = await res.json().catch(()=>({})); throw new Error(e.error?.message || 'HTTP '+res.status); }
  return (await res.json()).choices[0].message.content;
}

async function callGroqChat(msg) {
  const res = await fetch('https://api.groq.com/openai/v1/chat/completions', {
    method: 'POST',
    headers: {'Content-Type':'application/json','Authorization':'Bearer ' + apiKey},
    body: JSON.stringify({
      model: 'llama-3.3-70b-versatile',
      messages: [
        {role:'system', content:'Sei un assistente vocale per ipovedenti italiani. Rispondi in italiano, massimo 3 frasi parlate, senza elenchi, senza simboli, senza markdown. Il testo sara letto ad alta voce.'},
        {role:'user', content:msg}
      ],
      max_tokens: 250
    })
  });
  if (!res.ok) { const e = await res.json().catch(()=>({})); throw new Error(e.error?.message || 'HTTP '+res.status); }
  return (await res.json()).choices[0].message.content;
}

// ‚ïê‚ïê‚ïê GTT BUS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function toggleGTT() {
  gttOpen = !gttOpen;
  document.getElementById('gtt-panel').classList.toggle('open', gttOpen);
  if (!gttOpen) { stopGTTVoice(); stopStopVoice(); }
  setStatus(gttOpen ? 'Pannello bus aperto.' : 'Chiuso.', 'idle');
}

function getUserLocation() {
  if (!navigator.geolocation) { setStatus('GPS non disponibile.', 'error'); return; }
  setStatus('Rilevo GPS...', 'active');
  document.getElementById('gtt-coords').textContent = 'Rilevamento in corso...';
  navigator.geolocation.getCurrentPosition(
    (pos) => {
      userLat = pos.coords.latitude.toFixed(6);
      userLon = pos.coords.longitude.toFixed(6);
      document.getElementById('gtt-coords').textContent =
        'Posizione: lat ' + userLat + ' lon ' + userLon + ' (¬±' + Math.round(pos.coords.accuracy) + 'm). Ora premi CHIEDI.';
      setStatus('GPS rilevato.', 'active');
    },
    () => { document.getElementById('gtt-coords').textContent = 'GPS fallito. Controlla i permessi.'; setStatus('Errore GPS.', 'error'); },
    {enableHighAccuracy:true, timeout:15000}
  );
}

// ‚ïê‚ïê‚ïê ORARI FERMATA GTT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Variabili per voce fermata
let stopVoiceRec = null;
let isStopVoiceRec = false;
let stopVoiceTranscript = '';
let lastStopNumber = '';
let stopVoiceProcessed = false; // Anti-doppia esecuzione

// ‚ïê‚ïê‚ïê GTFS STATICO GTT ‚Äî cache in memoria ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Fonte: Feed GTFS GTT su aperTO (Comune di Torino) ‚Äî licenza CC BY 4.0
// Scaricato una sola volta per sessione, estratto in memoria, interrogato
// localmente: niente proxy instabili, niente scraping, niente HTTP 408.

// ‚îÄ‚îÄ GTFS ZIP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Fonte: Cloudflare Worker personale (gratuito, nessun limite dimensione, cache 6h)
// Istruzioni setup: vedi cloudflare-worker.js
//
// ‚öôÔ∏è  CAMBIA QUESTA RIGA con l'URL del tuo Cloudflare Worker dopo il deploy:
const GTFS_WORKER_URL  = 'https://gtt-gtfs.almunari.workers.dev';
//
const GTFS_ZIP_DIRECT  = 'https://www.gtt.to.it/open_data/gtt_gtfs.zip';
const GTFS_ZIP_GITHUB  = '/gtt_gtfs.zip'; // fallback: ZIP nel repo GitHub Pages
const GTFS_ZIP_SOURCES = [
  { url: GTFS_WORKER_URL, label: 'worker' },   // principale ‚Äî Cloudflare Worker
  { url: GTFS_ZIP_GITHUB, label: 'repo'   },   // fallback ‚Äî file nel repo
  { url: GTFS_ZIP_DIRECT, label: 'diretto'},   // ultimo tentativo ‚Äî diretto GTT
];

// Ultima data del feed scaricato (per mostrare all'utente)
let gtfsLastModified = null;

let gtfsCache = null; // riempito al primo uso

// Carica JSZip da CDN se non presente
async function ensureJSZip() {
  if (window.JSZip) return;
  await new Promise((res, rej) => {
    const s = document.createElement('script');
    s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
    s.onload = res; s.onerror = rej;
    document.head.appendChild(s);
  });
}

// Parse CSV semplice (gestisce campi quotati)
function parseCSV(txt) {
  const lines = txt.split(/\r?\n/);
  if (lines.length < 2) return [];
  const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
  return lines.slice(1).filter(l => l.trim()).map(l => {
    const vals = []; let cur = '', inQ = false;
    for (const ch of l) {
      if (ch === '"') { inQ = !inQ; }
      else if (ch === ',' && !inQ) { vals.push(cur); cur = ''; }
      else cur += ch;
    }
    vals.push(cur);
    const obj = {};
    headers.forEach((h, i) => { obj[h] = (vals[i] || '').replace(/^"|"$/g, '').trim(); });
    return obj;
  });
}

// Scarica e indicizza il GTFS ad ogni sessione (sempre fresco).
// Cache in memoria per la durata della sessione (evita di riscaricare
// se cerchi pi√π fermate di fila nella stessa apertura dell'app).
async function loadGTFS(onProgress) {
  if (gtfsCache) return gtfsCache; // gi√† caricato in questa sessione
  await ensureJSZip();

  onProgress('Scarico orari GTT aggiornati...');
  let zipData = null;
  const errors = [];
  for (const src of GTFS_ZIP_SOURCES) {
    try {
      onProgress('Scarico da ' + src.label + '...');
      const ctrl = new AbortController();
      const tid  = setTimeout(() => ctrl.abort(), 90000);
      const res  = await fetch(src.url, { signal: ctrl.signal, cache: 'no-store' });
      clearTimeout(tid);
      if (!res.ok) { errors.push(src.label + ':HTTP' + res.status); continue; }
      if (!gtfsLastModified) {
        const lm = res.headers.get('last-modified');
        if (lm) gtfsLastModified = new Date(lm);
      }
      zipData = await res.arrayBuffer();
      if (zipData.byteLength > 50000) {
        const dateStr = gtfsLastModified
          ? ' (' + gtfsLastModified.toLocaleDateString('it-IT',{day:'2-digit',month:'2-digit',year:'2-digit'}) + ')'
          : '';
        onProgress('Download OK' + dateStr);
        break;
      }
      errors.push(src.label + ':file piccolo'); zipData = null;
    } catch(e) { errors.push(src.label + ':' + e.message); }
  }
  if (!zipData) throw new Error('Download GTFS fallito: ' + errors.join('; '));

  onProgress('Estraggo e indicizzio dati GTT...');
  const zip = await JSZip.loadAsync(zipData);

  async function csv(name) {
    const f = zip.file(name);
    return f ? parseCSV(await f.async('string')) : [];
  }

  const [stopsRaw, tripsRaw, routesRaw, timesRaw, calRaw] = await Promise.all([
    csv('stops.txt'), csv('trips.txt'), csv('routes.txt'),
    csv('stop_times.txt'), csv('calendar.txt')
  ]);

  // routes: route_id ‚Üí short_name
  const routes = new Map();
  for (const r of routesRaw) routes.set(r.route_id, r.route_short_name || r.route_id);

  // calendar: service_id ‚Üí {days[7], start, end}  (lun=0 ‚Ä¶ dom=6)
  const calendar = new Map();
  for (const c of calRaw) {
    calendar.set(c.service_id, {
      days: [c.monday,c.tuesday,c.wednesday,c.thursday,c.friday,c.saturday,c.sunday].map(Number),
      start: c.start_date, end: c.end_date
    });
  }

  // trips: trip_id ‚Üí {route_id, service_id, headsign}
  const trips = new Map();
  for (const t of tripsRaw) trips.set(t.trip_id, { route_id: t.route_id, service_id: t.service_id, headsign: t.trip_headsign || '' });

  // stops: stop_code (numero palina senza zeri iniziali) ‚Üí stop_id
  const stopsByCode = new Map();
  const stopById    = new Map();
  for (const s of stopsRaw) {
    stopById.set(s.stop_id, { name: s.stop_name, code: s.stop_code || '' });
    if (s.stop_code) stopsByCode.set(s.stop_code.replace(/^0+/, ''), s.stop_id);
  }

  // stop_times: stop_id ‚Üí [{trip_id, arrival}]
  const stopTimes = new Map();
  for (const st of timesRaw) {
    if (!stopTimes.has(st.stop_id)) stopTimes.set(st.stop_id, []);
    stopTimes.get(st.stop_id).push({ trip_id: st.trip_id, arrival: st.arrival_time || st.departure_time });
  }

  gtfsCache = { stopsByCode, stopById, trips, routes, calendar, stopTimes };
  onProgress('Dati GTT pronti!');
  return gtfsCache;
}

// Controlla se un service_id √® attivo oggi
function isServiceActiveToday(cal) {
  if (!cal) return true;
  // Se tutti i giorni sono NaN (colonne mancanti nel CSV) ‚Üí assume attivo
  const allNaN = cal.days.every(v => isNaN(v));
  if (allNaN) return true;
  const d = new Date();
  const ds = d.getFullYear().toString() + String(d.getMonth()+1).padStart(2,'0') + String(d.getDate()).padStart(2,'0');
  if (cal.start && ds < cal.start) return false;
  if (cal.end   && ds > cal.end)   return false;
  const dow = d.getDay(); // 0=dom
  const idx = dow === 0 ? 6 : dow - 1; // lun=0‚Ä¶dom=6
  const val = cal.days[idx];
  return isNaN(val) ? true : val === 1;
}

// "HH:MM:SS" ‚Üí minuti da mezzanotte (GTFS supporta valori >24h per corse notturne)
function toMin(t) {
  if (!t) return 9999;
  const p = t.split(':');
  return parseInt(p[0]) * 60 + parseInt(p[1] || 0);
}

// Lookup fermata GTFS ‚Äî restituisce { lines, ora, stopName }
async function fetchGTTStop(stopNum) {
  lastStopNumber = stopNum;

  const gtfs = await loadGTFS((msg) => setGTTStopAnswer(msg));

  const now  = new Date();
  const hh   = String(now.getHours()).padStart(2,'0');
  const mm   = String(now.getMinutes()).padStart(2,'0');
  const ora  = hh + ':' + mm;
  const nowMin = parseInt(hh) * 60 + parseInt(mm);

  const cleanCode = String(stopNum).replace(/^0+/, '');
  const stopId = gtfs.stopsByCode.get(cleanCode);
  if (!stopId) throw new Error('Fermata ' + stopNum + ' non trovata nel database GTT.');

  const stopInfo = gtfs.stopById.get(stopId) || {};
  const times    = gtfs.stopTimes.get(stopId) || [];

  // Carica dati RT (silenzioso se non disponibile)
  let rtMap = new Map();
  try { rtMap = await loadGTFSRT(); } catch(e) {}
  const rtForStop = rtMap.get(stopId) || [];

  // Funzione helper: raccogli corse con overlay RT
  function collectInWindow(minFrom, minTo) {
    const found = [];
    for (const st of times) {
      const arrMin = toMin(st.arrival);
      if (arrMin < minFrom || arrMin > minTo) continue;
      const trip = gtfs.trips.get(st.trip_id);
      if (!trip) continue;
      if (!isServiceActiveToday(gtfs.calendar.get(trip.service_id))) continue;

      // Cerca aggiornamento RT per questa corsa
      const rtEntry = rtForStop.find(r => r.trip_id === st.trip_id);
      const delaySec    = rtEntry ? rtEntry.delay_sec    : null;
      const realtimeMin = rtEntry ? rtEntry.realtime_min : null;

      // Orario effettivo: usa timestamp RT se disponibile, altrimenti aggiunge delay
      let effectiveMin = arrMin;
      let effectiveStr = st.arrival.substring(0, 5);
      if (realtimeMin !== null) {
        effectiveMin = realtimeMin;
        effectiveStr = String(Math.floor(realtimeMin/60)).padStart(2,'0') + ':' + String(realtimeMin%60).padStart(2,'0');
      } else if (delaySec !== null) {
        effectiveMin = arrMin + Math.round(delaySec / 60);
        const eh = Math.floor(effectiveMin/60) % 24;
        const em = effectiveMin % 60;
        effectiveStr = String(eh).padStart(2,'0') + ':' + String(em).padStart(2,'0');
      }

      found.push({
        line: gtfs.routes.get(trip.route_id) || '?',
        dest: trip.headsign,
        arrMin: effectiveMin,
        arrival: effectiveStr,
        scheduled: st.arrival.substring(0, 5),
        delaySec,
        waitMin: effectiveMin - nowMin
      });
    }
    found.sort((a, b) => a.arrMin - b.arrMin);
    const byLine = new Map();
    for (const u of found) {
      const key = u.line + '|' + u.dest;
      if (!byLine.has(key)) byLine.set(key, { line: u.line, dest: u.dest, passages: [] });
      byLine.get(key).passages.push({ time: u.arrival, scheduled: u.scheduled, delaySec: u.delaySec, waitMin: u.waitMin });
    }
    return [...byLine.values()].map(l => ({ ...l, passages: l.passages.slice(0, 5) }));
  }

  // Prima finestra: prossimi 60 min; se vuota allarga a 120 min
  let lines = collectInWindow(nowMin, nowMin + 60);
  if (lines.length === 0) lines = collectInWindow(nowMin, nowMin + 120);

  return { lines, ora, stopName: stopInfo.name || ('Fermata ' + stopNum), hasRT: rtForStop.length > 0 };
}

// ‚ïê‚ïê‚ïê GTFS-RT GTT ‚Äî tempo reale con decoder protobuf inline ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Endpoint pubblici GTT (nessuna autenticazione richiesta):
//   trip_updates  ‚Üí ritardi e orari effettivi per fermata/corsa
//   vehicle_pos   ‚Üí posizioni GPS mezzi
// Il decoder protobuf √® implementato inline (no dipendenze npm/cdn pesanti).

// URL ufficiale verificato su Transitland/aperTO (das_gtfsrt, non das_gtt)
const GTFSRT_TRIP_URL = 'http://percorsieorari.gtt.to.it/das_gtfsrt/trip_update.aspx';
const GTFSRT_PROXIES  = [
  (u) => 'https://corsproxy.io/?url=' + encodeURIComponent(u),       // corsproxy.io (formato /?url= corretto)
  (u) => 'https://api.allorigins.win/raw?url=' + encodeURIComponent(u), // allorigins fallback
  (u) => 'https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent(u) // terzo fallback
];

// Cache RT: si azzera ogni 30 secondi
let gtfsRtCache = null;
let gtfsRtTimestamp = 0;
const GTFSRT_TTL = 30000; // 30s

// ‚îÄ‚îÄ Micro decoder protobuf (solo le varint + len-delimited che servono a GTFS-RT)
// Decodifica solo i campi che ci interessano: stop_id, arrival.delay, arrival.time, trip_id
const PB = {
  readVarint(buf, pos) {
    let val = 0, shift = 0, b;
    do { b = buf[pos++]; val |= (b & 0x7F) << shift; shift += 7; } while (b & 0x80);
    return { val, pos };
  },
  readFields(buf, start, end) {
    const fields = [];
    let pos = start;
    while (pos < end) {
      const tag = PB.readVarint(buf, pos); pos = tag.pos;
      const fieldNum = tag.val >>> 3;
      const wireType = tag.val & 0x7;
      if (wireType === 0) {       // varint
        const v = PB.readVarint(buf, pos); pos = v.pos;
        fields.push({ field: fieldNum, type: 'varint', val: v.val });
      } else if (wireType === 2) { // len-delimited
        const lenV = PB.readVarint(buf, pos); pos = lenV.pos;
        const bytes = buf.slice(pos, pos + lenV.val); pos += lenV.val;
        fields.push({ field: fieldNum, type: 'bytes', val: bytes });
      } else if (wireType === 1) { // 64-bit fixed
        pos += 8;
      } else if (wireType === 5) { // 32-bit fixed
        pos += 4;
      } else break; // sconosciuto, fermati
    }
    return fields;
  },
  str(bytes) { try { return new TextDecoder().decode(bytes); } catch(e) { return ''; } },
  sint32(v) { return (v >>> 1) ^ -(v & 1); } // zigzag decode per i delay (signed)
};

// Parsa il binario GTFS-RT e restituisce Map<stop_id ‚Üí [{trip_id, delay_sec, realtime_min}]>
function parseGTFSRT(buffer) {
  const buf  = new Uint8Array(buffer);
  const rtMap = new Map(); // stop_id ‚Üí [{trip_id, delay_sec, realtime_min}]

  // FeedMessage (campo 2 = entity[])
  const msgFields = PB.readFields(buf, 0, buf.length);
  for (const f of msgFields) {
    if (f.field !== 2 || f.type !== 'bytes') continue; // entity

    // FeedEntity: campo 4 = trip_update
    const entityFields = PB.readFields(f.val, 0, f.val.length);
    let tripUpdateBytes = null;
    for (const ef of entityFields) {
      if (ef.field === 4 && ef.type === 'bytes') { tripUpdateBytes = ef.val; break; }
    }
    if (!tripUpdateBytes) continue;

    // TripUpdate: campo 1=trip_descriptor, campo 2=stop_time_update[]
    const tuFields = PB.readFields(tripUpdateBytes, 0, tripUpdateBytes.length);
    let tripId = '';
    const stopUpdates = [];
    for (const tuf of tuFields) {
      if (tuf.field === 1 && tuf.type === 'bytes') {
        // TripDescriptor: campo 1=trip_id
        const tdFields = PB.readFields(tuf.val, 0, tuf.val.length);
        for (const td of tdFields) {
          if (td.field === 1 && td.type === 'bytes') { tripId = PB.str(td.val); break; }
        }
      }
      if (tuf.field === 2 && tuf.type === 'bytes') {
        // StopTimeUpdate: campo 4=stop_id, campo 2=arrival{campo 2=delay, campo 1=time}
        const stuFields = PB.readFields(tuf.val, 0, tuf.val.length);
        let stopId = '', delaySec = 0, realtimeTs = 0;
        for (const stu of stuFields) {
          if (stu.field === 4 && stu.type === 'bytes') stopId = PB.str(stu.val);
          if (stu.field === 2 && stu.type === 'bytes') { // arrival
            const arrFields = PB.readFields(stu.val, 0, stu.val.length);
            for (const ar of arrFields) {
              if (ar.field === 2 && ar.type === 'varint') delaySec = PB.sint32(ar.val);
              if (ar.field === 1 && ar.type === 'varint') realtimeTs = ar.val;
            }
          }
        }
        if (stopId) stopUpdates.push({ stopId, delaySec, realtimeTs });
      }
    }
    // Aggiungi alla mappa
    for (const su of stopUpdates) {
      let realtimeMin = null;
      if (su.realtimeTs) {
        const d = new Date(su.realtimeTs * 1000);
        realtimeMin = d.getHours() * 60 + d.getMinutes();
      }
      if (!rtMap.has(su.stopId)) rtMap.set(su.stopId, []);
      rtMap.get(su.stopId).push({ trip_id: tripId, delay_sec: su.delaySec, realtime_min: realtimeMin });
    }
  }
  return rtMap;
}

// Scarica e parsa il feed RT (con cache 30s)
async function loadGTFSRT() {
  if (gtfsRtCache && (Date.now() - gtfsRtTimestamp) < GTFSRT_TTL) return gtfsRtCache;
  const errors = [];
  for (const proxyFn of GTFSRT_PROXIES) {
    try {
      const ctrl = new AbortController();
      const tid  = setTimeout(() => ctrl.abort(), 15000);
      const res  = await fetch(proxyFn(GTFSRT_TRIP_URL), { signal: ctrl.signal });
      clearTimeout(tid);
      if (!res.ok) { errors.push('HTTP ' + res.status); continue; }
      const buf = await res.arrayBuffer();
      if (buf.byteLength < 10) { errors.push('risposta vuota'); continue; }
      gtfsRtCache     = parseGTFSRT(buf);
      gtfsRtTimestamp = Date.now();
      return gtfsRtCache;
    } catch(e) { errors.push(e.message); }
  }
  console.warn('GTFS-RT non disponibile:', errors.join('; '));
  return new Map(); // fallback silenzioso: usa solo orari statici
}


// Leggi numero fermata da foto
async function readStopFromPhoto() {
  if (!currentImageBase64) {
    speak('Nessuna foto. Prima scatta una foto della palina con il numero fermata.');
    return;
  }
  setGTTStopAnswer('Leggo il numero dalla foto...');
  setStatus('AI legge la foto...', 'active');
  try {
    const prompt = 'Questa √® una foto di una fermata GTT di Torino. Cerca il numero della palina/fermata (di solito un numero di 3-5 cifre scritto in grande sulla targhetta). Rispondi SOLO con il numero, senza altro testo. Se non lo trovi, scrivi "non trovato".';
    const result = await callGroqVision(prompt, currentImageBase64);
    const clean = result.replace(/[^0-9]/g, '').trim();
    if (!clean || clean.length < 2) {
      const msg = 'Non riesco a leggere il numero dalla foto. Prova a dire il numero vocalmente.';
      setGTTStopAnswer(msg);
      speak(msg);
      return;
    }
    setGTTStopAnswer('Numero fermata ' + clean + ' rilevato. Cerco gli orari...');
    await processStopNumber(clean);
  } catch(e) {
    setGTTStopAnswer('Errore lettura foto: ' + e.message);
    speak('Errore lettura foto.');
  }
}

// Elabora numero fermata e parla gli orari
async function processStopNumber(stopNum) {
  setStatus('Cerco orari fermata ' + stopNum + '...', 'active');
  try {
    const result = await fetchGTTStop(stopNum);
    if (result.lines.length === 0) {
      const msg = 'Fermata ' + stopNum + ': nessun passaggio trovato nelle prossime ore (ore ' + result.ora + ').';
      setGTTStopAnswer(msg);
      speak(msg);
      return;
    }
    // Costruisci risposta vocale e visiva (con dati RT se disponibili)
    const nomeStop = result.stopName || ('Fermata ' + stopNum);
    const dateStr  = gtfsLastModified
      ? '  üìÖ ' + gtfsLastModified.toLocaleDateString('it-IT',{day:'2-digit',month:'2-digit',year:'2-digit'})
      : '';
    const rtBadge  = result.hasRT ? ' üü¢ TEMPO REALE' : (' üîµ PROGRAMMATI' + dateStr);
    let voiceText  = nomeStop + ', ore ' + result.ora + '. ';
    let displayText = 'üìç ' + nomeStop + '  ‚è∞ ' + result.ora + rtBadge + '\n';

    for (const l of result.lines) {
      // Ogni passage ha {time, scheduled, delaySec, waitMin}
      let lineVoice = 'Linea ' + l.line + (l.dest ? ' per ' + l.dest : '') + ': ';
      let lineDisplay = 'üöå ' + l.line + (l.dest ? ' ‚Üí ' + l.dest : '') + '\n';

      const passageStrs = [];
      const voiceStrs   = [];
      for (const p of l.passages) {
        let delayLabel = '';
        let voiceDelay = '';
        if (p.delaySec !== null) {
          const delMin = Math.round(p.delaySec / 60);
          if (delMin > 0)       { delayLabel = ' (+' + delMin + 'min)'; voiceDelay = ', ritardo ' + delMin + ' minuti'; }
          else if (delMin < 0)  { delayLabel = ' (' + delMin + 'min)';  voiceDelay = ', anticipo ' + Math.abs(delMin) + ' minuti'; }
          else                  { delayLabel = ' (in orario)'; }
        }
        const waitStr = p.waitMin >= 0 ? 'tra ' + p.waitMin + ' min' : '';
        passageStrs.push(p.time + delayLabel + (waitStr ? '  ' + waitStr : ''));
        voiceStrs.push(p.time + voiceDelay);
      }
      lineDisplay += '‚è± ' + passageStrs.join('   ') + '\n';
      lineVoice   += voiceStrs.join(', ') + '. ';
      displayText += lineDisplay;
      voiceText   += lineVoice;
    }

    setGTTStopAnswer(displayText.trim());
    setStatus('Orari pronti' + (result.hasRT ? ' (tempo reale)' : '') + '.', 'active');
    lastVoiceText = voiceText;
    document.getElementById('btn-gtt-leggi').style.display = 'block';
    speak(voiceText);
  } catch(e) {
    const msg = 'Errore recupero orari: ' + e.message;
    setGTTStopAnswer(msg);
    speak('Errore nella ricerca degli orari. Controlla la connessione.');
    setStatus('Errore.', 'error');
  }
}

function setGTTStopAnswer(text) {
  document.getElementById('gtt-stop-answer').textContent = text;
  // Nascondi LEGGI e APRI durante caricamento
  const loading = !text || text.includes('...') || text.includes('Leggo') || text.includes('Cerco') || text.includes('Errore');
  document.getElementById('btn-gtt-leggi').style.display = loading ? 'none' : 'block';
  document.getElementById('btn-gtt-apri').style.display  = (loading || !lastStopNumber) ? 'none' : 'block';
}

function leggiOrari() {
  if (lastVoiceText) speak(lastVoiceText);
}

function openGTTStopPage() {
  if (!lastStopNumber) return;
  // Usa la URL arrivi (tempo reale, senza parametri extra) ‚Äî la pi√π diretta
  const url = 'https://www.gtt.to.it/cms/percorari/arrivi?palina=' + encodeURIComponent(lastStopNumber);
  setTimeout(() => speak('Apro la pagina GTT della fermata ' + lastStopNumber + '.'), 100);
  window.open(url, '_blank');
}

// Voce per numero fermata
function toggleStopVoice() {
  if (isStopVoiceRec) stopStopVoice();
  else startStopVoice();
}

function startStopVoice() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) { setStatus('Usa Safari su iPhone.', 'error'); return; }
  window.speechSynthesis.cancel();
  stopVoiceTranscript = '';
  stopVoiceProcessed = false;
  isStopVoiceRec = true;
  const btn = document.getElementById('btn-gtt-voce-fermata');
  btn.classList.add('recording');
  document.getElementById('gtt-stop-label').textContent = '‚èπ STOP';
  document.getElementById('gtt-stop-sub').textContent = 'In ascolto...';
  document.getElementById('gtt-stop-wave').classList.add('show');
  document.getElementById('gtt-stop-answer').textContent = 'In ascolto... Di\' il numero fermata.';
  stopVoiceRec = new SR();
  stopVoiceRec.lang = 'it-IT';
  stopVoiceRec.continuous = false;
  stopVoiceRec.interimResults = false;
  stopVoiceRec.maxAlternatives = 1;
  stopVoiceRec.onresult = (e) => {
    stopVoiceTranscript = e.results[0][0].transcript;
  };
  stopVoiceRec.onerror = (e) => {
    if (e.error === 'no-speech') return; // lascia che onend gestisca tutto normalmente
    isStopVoiceRec = false; resetStopVoiceUI();
    setStatus('Errore mic: ' + e.error, 'error');
  };
  stopVoiceRec.onend = () => {
    isStopVoiceRec = false;
    resetStopVoiceUI();
    if (!stopVoiceProcessed) {
      stopVoiceProcessed = true;
      setTimeout(processStopVoice, 600);
    }
  };
  try { stopVoiceRec.start(); }
  catch(e) { isStopVoiceRec = false; resetStopVoiceUI(); }
}

function stopStopVoice() {
  if (!isStopVoiceRec) return;
  isStopVoiceRec = false;
  if (stopVoiceRec) {
    // Non nullificare onend: quando stop() scatta, onend chiama processStopVoice
    const rec = stopVoiceRec;
    stopVoiceRec = null;
    try { rec.stop(); } catch(e){}
  }
  resetStopVoiceUI();
}

function resetStopVoiceUI() {
  const btn = document.getElementById('btn-gtt-voce-fermata');
  if (btn) btn.classList.remove('recording');
  const lbl = document.getElementById('gtt-stop-label');
  if (lbl) lbl.textContent = 'üé§ DI\' FERMATA';
  const sub = document.getElementById('gtt-stop-sub');
  if (sub) sub.textContent = 'Es: "fermata 1234"';
  const wave = document.getElementById('gtt-stop-wave');
  if (wave) wave.classList.remove('show');
}

async function processStopVoice() {
  const txt = stopVoiceTranscript.trim();
  if (!txt) {
    setGTTStopAnswer('Non ho sentito nulla. Riprova.');
    speak('Non ho sentito. Riprova.');
    return;
  }
  // Estrai numero dalla voce: "fermata 1234" o "millequattrocentocinque" o "1234"
  const numMatch = txt.match(/\d{2,5}/);
  if (numMatch) {
    const stopNum = numMatch[0];
    setGTTStopAnswer('Cerco fermata ' + stopNum + '...');
    await processStopNumber(stopNum);
  } else {
    // Prova a convertire parole in numero tramite AI
    setGTTStopAnswer('Elaboro: "' + txt + '"...');
    try {
      const aiNum = await callGroqChat('Estrai SOLO il numero della fermata da questo testo (rispondi solo con le cifre, nessun altro testo): "' + txt + '"');
      const cleaned = aiNum.replace(/[^0-9]/g, '').trim();
      if (cleaned && cleaned.length >= 2) {
        setGTTStopAnswer('Cerco fermata ' + cleaned + '...');
        await processStopNumber(cleaned);
      } else {
        setGTTStopAnswer('Non ho capito il numero fermata. Di\' per esempio: "fermata duemila". Hai detto: "' + txt + '"');
        speak('Non ho capito il numero. Riprova dicendo per esempio: fermata duemila.');
      }
    } catch(e) {
      const errMsg = 'Errore nella ricerca: ' + e.message;
      setGTTStopAnswer(errMsg);
      speak('Errore nella ricerca degli orari. Controlla la connessione.');
    }
  }
}

// Distanza in metri tra due coordinate
function haversine(lat1, lon1, lat2, lon2) {
  const R = 6371000, toRad = x => x * Math.PI / 180;
  const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return Math.round(R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)));
}

// Fermate bus reali vicino all'utente via Overpass API (dati OpenStreetMap)
async function getNearbyStops(lat, lon) {
  const q = `[out:json][timeout:12];
(
  node["highway"="bus_stop"](around:500,${lat},${lon});
  node["public_transport"="stop_position"]["bus"="yes"](around:500,${lat},${lon});
  node["public_transport"="stop_position"]["tram"="yes"](around:500,${lat},${lon});
);
out body 30;`;
  const res = await fetch('https://overpass-api.de/api/interpreter', {
    method:'POST',
    headers:{'Content-Type':'application/x-www-form-urlencoded'},
    body:'data=' + encodeURIComponent(q)
  });
  if (!res.ok) throw new Error('Overpass error');
  const data = await res.json();
  const seen = new Set(), stops = [];
  for (const el of (data.elements || [])) {
    const t = el.tags || {};
    const name   = t.name || t['name:it'] || '';
    const routes = t.route_ref || t.routes || t.local_ref || '';
    const key    = name + '|' + routes;
    if (seen.has(key) || (!name && !routes)) continue;
    seen.add(key);
    stops.push({ name, routes, dist: haversine(lat, lon, el.lat, el.lon) });
  }
  return stops.sort((a,b) => a.dist - b.dist).slice(0, 5);
}

// Geocodifica destinazione con Nominatim (OpenStreetMap)
async function geocodePlace(dest) {
  const url = 'https://nominatim.openstreetmap.org/search?q='
    + encodeURIComponent(dest + ', Torino, Italia')
    + '&format=json&limit=1&accept-language=it';
  const res = await fetch(url, {headers:{'User-Agent':'MyEYES/1.0 (accessibility app)'}});
  if (!res.ok) return null;
  const data = await res.json();
  if (!data.length) return null;
  return {
    lat: parseFloat(data[0].lat),
    lon: parseFloat(data[0].lon),
    name: (data[0].display_name || dest).split(',')[0]
  };
}

function toggleGTTVoice() {
  if (isGttRecording) stopGTTVoice();
  else                startGTTVoice();
}

function startGTTVoice() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) { setStatus('Usa Safari su iPhone.', 'error'); return; }
  // Ferma TTS sincrono
  window.speechSynthesis.cancel();
  document.getElementById('btn-stop-voice').style.display = 'none';
  gttTranscript  = '';
  gttProcessing  = false;
  isGttRecording = true;
  document.getElementById('btn-gtt-mic').classList.add('recording');
  document.getElementById('gtt-mic-label').textContent = 'STOP';
  document.getElementById('gtt-mic-sub').textContent   = 'Tocca per fermare';
  document.getElementById('gtt-wave-bar').classList.add('show');
  document.getElementById('gtt-answer').textContent    = 'In ascolto...';
  gttRecognition = new SR();
  gttRecognition.lang = 'it-IT';
  gttRecognition.continuous = true;
  gttRecognition.interimResults = true;
  gttRecognition.maxAlternatives = 1;
  gttRecognition.onresult = (e) => {
    let fin = '', int = '';
    for (let i = e.resultIndex; i < e.results.length; i++) {
      if (e.results[i].isFinal) fin += e.results[i][0].transcript + ' ';
      else int += e.results[i][0].transcript;
    }
    gttTranscript += fin;
    document.getElementById('gtt-answer').textContent = (gttTranscript + int).trim() || 'In ascolto...';
  };
  gttRecognition.onerror = (e) => {
    if (e.error === 'no-speech' || e.error === 'aborted') return;
    isGttRecording = false; resetGTTVoiceUI();
    setStatus(e.error === 'not-allowed' ? 'Permesso negato.' : 'Errore mic: ' + e.error, 'error');
  };
  // onend: su Safari scatta automaticamente dopo silenzio
  // SE isGttRecording=true ‚Üí riavvia
  // SE isGttRecording=false ‚Üí l'utente ha premuto STOP ‚Üí NON chiamare processGTTVoice qui
  //    perch√© stopGTTVoice() ha gi√† schedulato il setTimeout
  gttRecognition.onend = () => {
    if (isGttRecording) {
      try { gttRecognition.start(); }
      catch(err) { isGttRecording = false; resetGTTVoiceUI(); triggerGTTProcess(); }
    }
    // Se !isGttRecording: stopGTTVoice() gestisce tutto ‚Äî non fare nulla qui
  };
  try { gttRecognition.start(); }
  catch(e) { isGttRecording = false; resetGTTVoiceUI(); setStatus('Errore avvio mic.', 'error'); }
}

function stopGTTVoice() {
  if (!isGttRecording) return;
  isGttRecording = false;
  gttProcessing  = false;
  if (gttRecognition) {
    gttRecognition.onend   = null;
    gttRecognition.onerror = null;
    // NON nullificare onresult subito: Safari deve ancora consegnare l'ultimo risultato finale
    const rec = gttRecognition;
    gttRecognition = null;
    try { rec.stop(); } catch(e){}
    setTimeout(() => { try { rec.onresult = null; } catch(e){} }, 500);
  }
  resetGTTVoiceUI();
  // 1200ms: 500ms per onresult finale + 700ms per rilascio audio Safari
  setTimeout(triggerGTTProcess, 1200);
}

function triggerGTTProcess() {
  if (gttProcessing) return; // Evita doppia esecuzione
  gttProcessing = true;
  processGTTVoice();
}

function resetGTTVoiceUI() {
  document.getElementById('btn-gtt-mic').classList.remove('recording');
  document.getElementById('gtt-mic-label').textContent = 'CHIEDI';
  document.getElementById('gtt-mic-sub').textContent   = 'Dove vuoi andare?';
  document.getElementById('gtt-wave-bar').classList.remove('show');
}

async function processGTTVoice() {
  const dest = gttTranscript.trim();
  if (!dest) {
    document.getElementById('gtt-answer').textContent = 'Non ho sentito nulla. Riprova.';
    speak('Non ho sentito nulla. Riprova.');
    gttProcessing = false;
    return;
  }

  document.getElementById('gtt-answer').textContent = 'Cerco: ' + dest + '...';
  setStatus('Cerco trasporti...', 'active');

  try {
    // STEP 1: Geocodifica destinazione
    let destInfo = '';
    let destLat = null, destLon = null;
    try {
      const geo = await geocodePlace(dest);
      if (geo) {
        destLat = geo.lat; destLon = geo.lon;
        destInfo = 'La destinazione "' + dest + '" si trova alle coordinate lat ' + geo.lat.toFixed(4) + ' lon ' + geo.lon.toFixed(4) + '.';
      } else {
        destInfo = 'La destinazione richiesta e: ' + dest + ' a Torino.';
      }
    } catch(e) {
      destInfo = 'Destinazione: ' + dest + ' a Torino.';
    }

    // STEP 2: Fermate vicino all'utente (se ha GPS)
    let stopsInfo = '';
    if (userLat && userLon) {
      try {
        const stops = await getNearbyStops(userLat, userLon);
        if (stops.length > 0) {
          stopsInfo = 'Le fermate bus e tram reali vicino a me sono: ' +
            stops.map(s => {
              let desc = '';
              if (s.name) desc += s.name;
              if (s.routes) desc += (desc ? ' (linee: ' + s.routes + ')' : 'linee ' + s.routes);
              desc += ' a ' + s.dist + ' metri';
              return desc;
            }).join('; ') + '.';
        } else {
          stopsInfo = 'Non trovo fermate GTT nelle vicinanze immediate.';
        }
      } catch(e) {
        stopsInfo = 'Impossibile caricare le fermate vicine.';
      }
    }

    // STEP 3: AI con dati reali
    const posInfo = (userLat && userLon)
      ? 'La mia posizione GPS e lat ' + userLat + ' lon ' + userLon + ' a Torino.'
      : 'Sono a Torino, posizione non disponibile.';

    const prompt = posInfo + ' ' + stopsInfo + ' ' + destInfo +
      ' Basandoti sulle fermate reali elencate sopra, dimmi in italiano parlato:' +
      ' quale linea GTT prendere (bus o tram), da quale fermata partire (usa i nomi reali che ti ho dato),' +
      ' dove scendere. Massimo 3 frasi brevi, zero elenchi, zero simboli.';

    const answer = await callGroqChat(prompt);
    const clean  = answer.replace(/[*_#`>]/g, '').trim();

    document.getElementById('gtt-answer').textContent = clean;
    setStatus('Risposta GTT pronta.', 'active');

    // Estrai numero linea per il link GTT
    const m = clean.match(/\b(?:linea|tram|bus|numero)\s*([A-Z]?\d{1,3}[A-Z]?)\b/i);
    lastGTTLineNumber = m ? m[1] : '';

    speak(clean);

  } catch(err) {
    document.getElementById('gtt-answer').textContent = 'Errore: ' + err.message;
    speak('Errore di rete. Controlla la connessione.');
    setStatus('Errore.', 'error');
  }
  gttProcessing = false;
}

function openGTTRealtime() {
  const url = 'https://www.gtt.to.it/cms/percorari/urbano?view=linee&bacino=U' +
    (lastGTTLineNumber ? '&linea=' + encodeURIComponent(lastGTTLineNumber) : '');
  speak(lastGTTLineNumber ? 'Apro gli orari della linea ' + lastGTTLineNumber + '.' : 'Apro gli orari GTT.');
  window.open(url, '_blank');
}

// ‚ïê‚ïê‚ïê EXIT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function exitApp() {
  window.speechSynthesis.cancel();
  if (recognition)    { try { recognition.stop();    } catch(e){} recognition    = null; }
  if (gttRecognition) { try { gttRecognition.stop(); } catch(e){} gttRecognition = null; }
  if (stopVoiceRec)   { try { stopVoiceRec.stop();   } catch(e){} stopVoiceRec   = null; }
  isRecording = isGttRecording = isStopVoiceRec = false;
  resetVoiceUI(); resetGTTVoiceUI(); resetStopVoiceUI();
  document.getElementById('app').style.display          = 'none';
  document.getElementById('settings-fab').style.display = 'none';
  document.getElementById('exit-screen').style.display  = 'flex';
  const u = new SpeechSynthesisUtterance('Arrivederci.');
  u.lang = 'it-IT'; u.rate = 0.93;
  u.onend = () => { try { window.close(); } catch(e){} };
  setTimeout(() => window.speechSynthesis.speak(u), 80);
}

function reopenApp() {
  document.getElementById('exit-screen').style.display  = 'none';
  document.getElementById('app').style.display          = 'flex';
  document.getElementById('settings-fab').style.display = 'flex';
}

// ‚ïê‚ïê‚ïê SETTINGS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function openSettings()  { document.getElementById('settings-key').value = apiKey; document.getElementById('settings-overlay').classList.add('open'); }
function closeSettings() { document.getElementById('settings-overlay').classList.remove('open'); }
function closeSettingsIfBg(e) { if (e.target === document.getElementById('settings-overlay')) closeSettings(); }
function saveKeyFromSettings() {
  const val = document.getElementById('settings-key').value.trim();
  if (val.startsWith('gsk_')) { apiKey = val; closeSettings(); speak('Chiave salvata.'); }
  else speak('Chiave non valida. Deve iniziare con gsk.');
}
</script>
</body>
</html>
